/*
 * Argos Notary - A new way to secure the Software Supply Chain
 *
 * Copyright (C) 2019 - 2020 Rabobank Nederland
 * Copyright (C) 2019 - 2021 Gerard Borst <gerard.borst@argosnotary.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
/* tslint:disable */
/* eslint-disable */
/**
 * Argos Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof AccountInfo
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    path?: string;
    /**
     * 
     * @type {AccountType}
     * @memberof AccountInfo
     */
    accountType?: AccountType;
}
/**
 * 
 * @export
 * @interface AccountKeyInfo
 */
export interface AccountKeyInfo {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof AccountKeyInfo
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyInfo
     */
    path?: string;
    /**
     * 
     * @type {AccountType}
     * @memberof AccountKeyInfo
     */
    accountType?: AccountType;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyInfo
     */
    keyId: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyInfo
     */
    keyStatus: AccountKeyInfoKeyStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AccountKeyInfoKeyStatusEnum {
    ACTIVE = 'ACTIVE',
    INACTIVE = 'INACTIVE',
    DELETED = 'DELETED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AccountType {
    SERVICE_ACCOUNT = 'SERVICE_ACCOUNT',
    PERSONAL_ACCOUNT = 'PERSONAL_ACCOUNT'
}

/**
 * 
 * @export
 * @interface ApprovalConfiguration
 */
export interface ApprovalConfiguration {
    /**
     * 
     * @type {string}
     * @memberof ApprovalConfiguration
     */
    stepName: string;
    /**
     * 
     * @type {string}
     * @memberof ApprovalConfiguration
     */
    segmentName: string;
    /**
     * 
     * @type {Array<ArtifactCollectorSpecification>}
     * @memberof ApprovalConfiguration
     */
    artifactCollectorSpecifications: Array<ArtifactCollectorSpecification>;
}
/**
 * 
 * @export
 * @interface Artifact
 */
export interface Artifact {
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    uri: string;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    hash: string;
}
/**
 * 
 * @export
 * @interface ArtifactCollectorSpecification
 */
export interface ArtifactCollectorSpecification {
    /**
     * 
     * @type {string}
     * @memberof ArtifactCollectorSpecification
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactCollectorSpecification
     */
    type: ArtifactCollectorSpecificationTypeEnum;
    /**
     * base url of the artifact collector server
     * @type {string}
     * @memberof ArtifactCollectorSpecification
     */
    uri: string;
    /**
     * additional key value pair attributes that can very per collector type for XLDEPLOY the key is \'applicationName\'
     * @type {{ [key: string]: string; }}
     * @memberof ArtifactCollectorSpecification
     */
    context: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactCollectorSpecificationTypeEnum {
    XLDEPLOY = 'XLDEPLOY',
    GIT = 'GIT'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum HashAlgorithm {
    SHA256 = 'SHA256',
    SHA384 = 'SHA384',
    SHA512 = 'SHA512'
}

/**
 * The mode of the returned descendants in a tree node hierarchy. ALL returns all descendants, NONE returns nodes without any descendants , MAX_DEPTH returns descendants up to a specified depth
 * @export
 * @enum {string}
 */
export enum HierarchyMode {
    ALL = 'ALL',
    NONE = 'NONE',
    MAX_DEPTH = 'MAX_DEPTH'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum KeyAlgorithm {
    EC = 'EC'
}

/**
 * 
 * @export
 * @interface KeyPair
 */
export interface KeyPair {
    /**
     * 
     * @type {string}
     * @memberof KeyPair
     */
    keyId: string;
    /**
     * 
     * @type {string}
     * @memberof KeyPair
     */
    publicKey: string;
    /**
     * 
     * @type {string}
     * @memberof KeyPair
     */
    encryptedPrivateKey: string;
}
/**
 * 
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof Label
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    name: string;
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof Label
     */
    parentLabelId?: string;
}
/**
 * 
 * @export
 * @interface Layout
 */
export interface Layout {
    /**
     * 
     * @type {Array<PublicKey>}
     * @memberof Layout
     */
    keys: Array<PublicKey>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Layout
     */
    authorizedKeyIds: Array<string>;
    /**
     * 
     * @type {Array<MatchRule>}
     * @memberof Layout
     */
    expectedEndProducts: Array<MatchRule>;
    /**
     * 
     * @type {Array<LayoutSegment>}
     * @memberof Layout
     */
    layoutSegments: Array<LayoutSegment>;
}
/**
 * 
 * @export
 * @interface LayoutMetaBlock
 */
export interface LayoutMetaBlock {
    /**
     * 
     * @type {Array<Signature>}
     * @memberof LayoutMetaBlock
     */
    signatures: Array<Signature>;
    /**
     * 
     * @type {Layout}
     * @memberof LayoutMetaBlock
     */
    layout: Layout;
}
/**
 * 
 * @export
 * @interface LayoutSegment
 */
export interface LayoutSegment {
    /**
     * 
     * @type {string}
     * @memberof LayoutSegment
     */
    name: string;
    /**
     * 
     * @type {Array<Step>}
     * @memberof LayoutSegment
     */
    steps: Array<Step>;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    runId: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    stepName: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    layoutSegmentName: string;
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof Link
     */
    materials: Array<Artifact>;
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof Link
     */
    products: Array<Artifact>;
}
/**
 * 
 * @export
 * @interface LinkMetaBlock
 */
export interface LinkMetaBlock {
    /**
     * 
     * @type {Signature}
     * @memberof LinkMetaBlock
     */
    signature: Signature;
    /**
     * 
     * @type {Link}
     * @memberof LinkMetaBlock
     */
    link: Link;
}
/**
 * 
 * @export
 * @interface LocalPermissions
 */
export interface LocalPermissions {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof LocalPermissions
     */
    labelId: string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof LocalPermissions
     */
    permissions: Array<Permission>;
}
/**
 * 
 * @export
 * @interface MatchRule
 */
export interface MatchRule {
    /**
     * 
     * @type {string}
     * @memberof MatchRule
     */
    pattern: string;
    /**
     * 
     * @type {string}
     * @memberof MatchRule
     */
    sourcePathPrefix?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchRule
     */
    destinationType: MatchRuleDestinationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MatchRule
     */
    destinationPathPrefix?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchRule
     */
    destinationSegmentName: string;
    /**
     * 
     * @type {string}
     * @memberof MatchRule
     */
    destinationStepName: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MatchRuleDestinationTypeEnum {
    PRODUCTS = 'PRODUCTS',
    MATERIALS = 'MATERIALS'
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message: string;
}
/**
 * 
 * @export
 * @interface OAuthProvider
 */
export interface OAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    providerName?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    iconUrl?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Permission {
    READ = 'READ',
    TREE_EDIT = 'TREE_EDIT',
    LOCAL_PERMISSION_EDIT = 'LOCAL_PERMISSION_EDIT',
    LINK_ADD = 'LINK_ADD',
    RELEASE = 'RELEASE',
    ASSIGN_ROLE = 'ASSIGN_ROLE'
}

/**
 * 
 * @export
 * @interface PersonalAccount
 */
export interface PersonalAccount {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof PersonalAccount
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonalAccount
     */
    name?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof PersonalAccount
     */
    roles?: Array<Role>;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof Profile
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    email?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof Profile
     */
    roles?: Array<Role>;
}
/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    keyId: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    publicKey: string;
}
/**
 * 
 * @export
 * @interface ReleaseArtifacts
 */
export interface ReleaseArtifacts {
    /**
     * 
     * @type {Array<Array<Artifact>>}
     * @memberof ReleaseArtifacts
     */
    releaseArtifacts?: Array<Array<Artifact>>;
}
/**
 * 
 * @export
 * @interface ReleaseConfiguration
 */
export interface ReleaseConfiguration {
    /**
     * 
     * @type {Array<ArtifactCollectorSpecification>}
     * @memberof ReleaseConfiguration
     */
    artifactCollectorSpecifications: Array<ArtifactCollectorSpecification>;
}
/**
 * 
 * @export
 * @interface ReleaseDossierMetaData
 */
export interface ReleaseDossierMetaData {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof ReleaseDossierMetaData
     */
    documentId?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseDossierMetaData
     */
    releaseDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseDossierMetaData
     */
    supplyChainPath?: string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof ReleaseDossierMetaData
     */
    releaseArtifacts?: Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface ReleaseResult
 */
export interface ReleaseResult {
    /**
     * 
     * @type {boolean}
     * @memberof ReleaseResult
     */
    releaseIsValid?: boolean;
    /**
     * 
     * @type {ReleaseDossierMetaData}
     * @memberof ReleaseResult
     */
    releaseDossierMetaData?: ReleaseDossierMetaData;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    ADMINISTRATOR = 'ADMINISTRATOR'
}

/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    ruleType: RuleRuleTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    pattern: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    sourcePathPrefix?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    destinationPathPrefix?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    destinationSegmentName?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    destinationType?: RuleDestinationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    destinationStepName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RuleRuleTypeEnum {
    ALLOW = 'ALLOW',
    CREATE = 'CREATE',
    CREATE_OR_MODIFY = 'CREATE_OR_MODIFY',
    DELETE = 'DELETE',
    DISALLOW = 'DISALLOW',
    MATCH = 'MATCH',
    MODIFY = 'MODIFY',
    REQUIRE = 'REQUIRE'
}
/**
    * @export
    * @enum {string}
    */
export enum RuleDestinationTypeEnum {
    PRODUCTS = 'PRODUCTS',
    MATERIALS = 'MATERIALS'
}

/**
 * 
 * @export
 * @interface ServiceAccount
 */
export interface ServiceAccount {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof ServiceAccount
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccount
     */
    name: string;
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof ServiceAccount
     */
    parentLabelId: string;
}
/**
 * 
 * @export
 * @interface ServiceAccountKeyPair
 */
export interface ServiceAccountKeyPair {
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountKeyPair
     */
    keyId: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountKeyPair
     */
    publicKey: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountKeyPair
     */
    encryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountKeyPair
     */
    hashedKeyPassphrase: string;
}
/**
 * 
 * @export
 * @interface Signature
 */
export interface Signature {
    /**
     * 
     * @type {string}
     * @memberof Signature
     */
    keyId: string;
    /**
     * 
     * @type {string}
     * @memberof Signature
     */
    signature: string;
    /**
     * 
     * @type {HashAlgorithm}
     * @memberof Signature
     */
    hashAlgorithm: HashAlgorithm;
    /**
     * 
     * @type {KeyAlgorithm}
     * @memberof Signature
     */
    keyAlgorithm: KeyAlgorithm;
}
/**
 * 
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Step
     */
    authorizedKeyIds: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    requiredNumberOfLinks: number;
    /**
     * 
     * @type {Array<Rule>}
     * @memberof Step
     */
    expectedMaterials: Array<Rule>;
    /**
     * 
     * @type {Array<Rule>}
     * @memberof Step
     */
    expectedProducts: Array<Rule>;
}
/**
 * 
 * @export
 * @interface SupplyChain
 */
export interface SupplyChain {
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof SupplyChain
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplyChain
     */
    name: string;
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof SupplyChain
     */
    parentLabelId: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token: string;
}
/**
 * 
 * @export
 * @interface TreeNode
 */
export interface TreeNode {
    /**
     * 
     * @type {string}
     * @memberof TreeNode
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TreeNode
     */
    type: TreeNodeTypeEnum;
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof TreeNode
     */
    referenceId: string;
    /**
     * an Argos Service identifier
     * @type {string}
     * @memberof TreeNode
     */
    parentLabelId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TreeNode
     */
    hasChildren: boolean;
    /**
     * 
     * @type {Array<TreeNode>}
     * @memberof TreeNode
     */
    children: Array<TreeNode>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof TreeNode
     */
    permissions?: Array<Permission>;
}

/**
    * @export
    * @enum {string}
    */
export enum TreeNodeTypeEnum {
    LABEL = 'LABEL',
    SUPPLY_CHAIN = 'SUPPLY_CHAIN',
    SERVICE_ACCOUNT = 'SERVICE_ACCOUNT'
}

/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationMessage>}
     * @memberof ValidationError
     */
    messages: Array<ValidationMessage>;
}
/**
 * 
 * @export
 * @interface ValidationMessage
 */
export interface ValidationMessage {
    /**
     * 
     * @type {string}
     * @memberof ValidationMessage
     */
    field?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationMessage
     */
    type: ValidationMessageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ValidationMessage
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ValidationMessageTypeEnum {
    DATA_INPUT = 'DATA_INPUT',
    MODEL_CONSISTENCY = 'MODEL_CONSISTENCY'
}

/**
 * 
 * @export
 * @interface VerificationResult
 */
export interface VerificationResult {
    /**
     * 
     * @type {boolean}
     * @memberof VerificationResult
     */
    runIsValid: boolean;
}
/**
 * 
 * @export
 * @interface VerifyCommand
 */
export interface VerifyCommand {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof VerifyCommand
     */
    expectedProducts: Array<Artifact>;
}

/**
 * HierarchyApi - axios parameter creator
 * @export
 */
export const HierarchyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create a new label
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabel: async (label?: Label, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/label`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete label by id
         * @param {string} labelId label id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLabelById: async (labelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'labelId' is not null or undefined
            if (labelId === null || labelId === undefined) {
                throw new RequiredError('labelId','Required parameter labelId was null or undefined when calling deleteLabelById.');
            }
            const localVarPath = `/label/{labelId}`
                .replace(`{${"labelId"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get label by id
         * @param {string} labelId label id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelById: async (labelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'labelId' is not null or undefined
            if (labelId === null || labelId === undefined) {
                throw new RequiredError('labelId','Required parameter labelId was null or undefined when calling getLabelById.');
            }
            const localVarPath = `/label/{labelId}`
                .replace(`{${"labelId"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all root nodes
         * @param {HierarchyMode} [hierarchyMode] 
         * @param {number} [maxDepth] positive integer specifying the maximum levels of descendants that are returned in a search. This parameter is ignored in case of HierarchyhMode ALL and NONE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootNodes: async (hierarchyMode?: HierarchyMode, maxDepth?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hierarchy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (hierarchyMode !== undefined) {
                localVarQueryParameter['HierarchyMode'] = hierarchyMode;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['maxDepth'] = maxDepth;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a subtree
         * @param {string} referenceId this will be the root id of the returned sub tree
         * @param {HierarchyMode} [hierarchyMode] 
         * @param {number} [maxDepth] positive integer specifying the maximum levels of descendants that are retured this parameter is ignored in case of HierarchyhMode ALL and NONE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubTree: async (referenceId: string, hierarchyMode?: HierarchyMode, maxDepth?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'referenceId' is not null or undefined
            if (referenceId === null || referenceId === undefined) {
                throw new RequiredError('referenceId','Required parameter referenceId was null or undefined when calling getSubTree.');
            }
            const localVarPath = `/hierarchy/{referenceId}`
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (hierarchyMode !== undefined) {
                localVarQueryParameter['HierarchyMode'] = hierarchyMode;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['maxDepth'] = maxDepth;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update label by id
         * @param {string} labelId label id
         * @param {Label} label 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLabelById: async (labelId: string, label: Label, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'labelId' is not null or undefined
            if (labelId === null || labelId === undefined) {
                throw new RequiredError('labelId','Required parameter labelId was null or undefined when calling updateLabelById.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling updateLabelById.');
            }
            const localVarPath = `/label/{labelId}`
                .replace(`{${"labelId"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HierarchyApi - functional programming interface
 * @export
 */
export const HierarchyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create a new label
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLabel(label?: Label, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await HierarchyApiAxiosParamCreator(configuration).createLabel(label, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary delete label by id
         * @param {string} labelId label id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLabelById(labelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HierarchyApiAxiosParamCreator(configuration).deleteLabelById(labelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get label by id
         * @param {string} labelId label id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLabelById(labelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await HierarchyApiAxiosParamCreator(configuration).getLabelById(labelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all root nodes
         * @param {HierarchyMode} [hierarchyMode] 
         * @param {number} [maxDepth] positive integer specifying the maximum levels of descendants that are returned in a search. This parameter is ignored in case of HierarchyhMode ALL and NONE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootNodes(hierarchyMode?: HierarchyMode, maxDepth?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeNode>>> {
            const localVarAxiosArgs = await HierarchyApiAxiosParamCreator(configuration).getRootNodes(hierarchyMode, maxDepth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get a subtree
         * @param {string} referenceId this will be the root id of the returned sub tree
         * @param {HierarchyMode} [hierarchyMode] 
         * @param {number} [maxDepth] positive integer specifying the maximum levels of descendants that are retured this parameter is ignored in case of HierarchyhMode ALL and NONE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubTree(referenceId: string, hierarchyMode?: HierarchyMode, maxDepth?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeNode>> {
            const localVarAxiosArgs = await HierarchyApiAxiosParamCreator(configuration).getSubTree(referenceId, hierarchyMode, maxDepth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary update label by id
         * @param {string} labelId label id
         * @param {Label} label 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLabelById(labelId: string, label: Label, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await HierarchyApiAxiosParamCreator(configuration).updateLabelById(labelId, label, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HierarchyApi - factory interface
 * @export
 */
export const HierarchyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary create a new label
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabel(label?: Label, options?: any): AxiosPromise<Label> {
            return HierarchyApiFp(configuration).createLabel(label, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete label by id
         * @param {string} labelId label id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLabelById(labelId: string, options?: any): AxiosPromise<void> {
            return HierarchyApiFp(configuration).deleteLabelById(labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get label by id
         * @param {string} labelId label id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelById(labelId: string, options?: any): AxiosPromise<Label> {
            return HierarchyApiFp(configuration).getLabelById(labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all root nodes
         * @param {HierarchyMode} [hierarchyMode] 
         * @param {number} [maxDepth] positive integer specifying the maximum levels of descendants that are returned in a search. This parameter is ignored in case of HierarchyhMode ALL and NONE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootNodes(hierarchyMode?: HierarchyMode, maxDepth?: number, options?: any): AxiosPromise<Array<TreeNode>> {
            return HierarchyApiFp(configuration).getRootNodes(hierarchyMode, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a subtree
         * @param {string} referenceId this will be the root id of the returned sub tree
         * @param {HierarchyMode} [hierarchyMode] 
         * @param {number} [maxDepth] positive integer specifying the maximum levels of descendants that are retured this parameter is ignored in case of HierarchyhMode ALL and NONE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubTree(referenceId: string, hierarchyMode?: HierarchyMode, maxDepth?: number, options?: any): AxiosPromise<TreeNode> {
            return HierarchyApiFp(configuration).getSubTree(referenceId, hierarchyMode, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update label by id
         * @param {string} labelId label id
         * @param {Label} label 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLabelById(labelId: string, label: Label, options?: any): AxiosPromise<Label> {
            return HierarchyApiFp(configuration).updateLabelById(labelId, label, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HierarchyApi - object-oriented interface
 * @export
 * @class HierarchyApi
 * @extends {BaseAPI}
 */
export class HierarchyApi extends BaseAPI {
    /**
     * 
     * @summary create a new label
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public createLabel(label?: Label, options?: any) {
        return HierarchyApiFp(this.configuration).createLabel(label, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete label by id
     * @param {string} labelId label id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public deleteLabelById(labelId: string, options?: any) {
        return HierarchyApiFp(this.configuration).deleteLabelById(labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get label by id
     * @param {string} labelId label id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public getLabelById(labelId: string, options?: any) {
        return HierarchyApiFp(this.configuration).getLabelById(labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all root nodes
     * @param {HierarchyMode} [hierarchyMode] 
     * @param {number} [maxDepth] positive integer specifying the maximum levels of descendants that are returned in a search. This parameter is ignored in case of HierarchyhMode ALL and NONE
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public getRootNodes(hierarchyMode?: HierarchyMode, maxDepth?: number, options?: any) {
        return HierarchyApiFp(this.configuration).getRootNodes(hierarchyMode, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a subtree
     * @param {string} referenceId this will be the root id of the returned sub tree
     * @param {HierarchyMode} [hierarchyMode] 
     * @param {number} [maxDepth] positive integer specifying the maximum levels of descendants that are retured this parameter is ignored in case of HierarchyhMode ALL and NONE
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public getSubTree(referenceId: string, hierarchyMode?: HierarchyMode, maxDepth?: number, options?: any) {
        return HierarchyApiFp(this.configuration).getSubTree(referenceId, hierarchyMode, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update label by id
     * @param {string} labelId label id
     * @param {Label} label 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public updateLabelById(labelId: string, label: Label, options?: any) {
        return HierarchyApiFp(this.configuration).updateLabelById(labelId, label, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LayoutApi - axios parameter creator
 * @export
 */
export const LayoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create approval configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {Array<ApprovalConfiguration>} approvalConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApprovalConfigurations: async (supplyChainId: string, approvalConfiguration: Array<ApprovalConfiguration>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling createApprovalConfigurations.');
            }
            // verify required parameter 'approvalConfiguration' is not null or undefined
            if (approvalConfiguration === null || approvalConfiguration === undefined) {
                throw new RequiredError('approvalConfiguration','Required parameter approvalConfiguration was null or undefined when calling createApprovalConfigurations.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/layout/approvalconfig`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof approvalConfiguration !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(approvalConfiguration !== undefined ? approvalConfiguration : {})
                : (approvalConfiguration || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create or update a layout
         * @param {string} supplyChainId supply chain id
         * @param {LayoutMetaBlock} layoutMetaBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateLayout: async (supplyChainId: string, layoutMetaBlock: LayoutMetaBlock, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling createOrUpdateLayout.');
            }
            // verify required parameter 'layoutMetaBlock' is not null or undefined
            if (layoutMetaBlock === null || layoutMetaBlock === undefined) {
                throw new RequiredError('layoutMetaBlock','Required parameter layoutMetaBlock was null or undefined when calling createOrUpdateLayout.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/layout`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof layoutMetaBlock !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(layoutMetaBlock !== undefined ? layoutMetaBlock : {})
                : (layoutMetaBlock || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create release configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {ReleaseConfiguration} releaseConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReleaseConfiguration: async (supplyChainId: string, releaseConfiguration: ReleaseConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling createReleaseConfiguration.');
            }
            // verify required parameter 'releaseConfiguration' is not null or undefined
            if (releaseConfiguration === null || releaseConfiguration === undefined) {
                throw new RequiredError('releaseConfiguration','Required parameter releaseConfiguration was null or undefined when calling createReleaseConfiguration.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/layout/releaseconfig`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof releaseConfiguration !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(releaseConfiguration !== undefined ? releaseConfiguration : {})
                : (releaseConfiguration || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns a list of approval configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalConfigurations: async (supplyChainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling getApprovalConfigurations.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/layout/approvalconfig`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns a list of approvals for the login user
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalsForAccount: async (supplyChainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling getApprovalsForAccount.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/layout/approvalconfig/me`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayout: async (supplyChainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling getLayout.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/layout`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns release configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseConfiguration: async (supplyChainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling getReleaseConfiguration.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/layout/releaseconfig`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary validates a layout on data input and model consistency
         * @param {string} supplyChainId supply chain id
         * @param {Layout} layout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLayout: async (supplyChainId: string, layout: Layout, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling validateLayout.');
            }
            // verify required parameter 'layout' is not null or undefined
            if (layout === null || layout === undefined) {
                throw new RequiredError('layout','Required parameter layout was null or undefined when calling validateLayout.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/layout/validate`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof layout !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(layout !== undefined ? layout : {})
                : (layout || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LayoutApi - functional programming interface
 * @export
 */
export const LayoutApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create approval configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {Array<ApprovalConfiguration>} approvalConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApprovalConfigurations(supplyChainId: string, approvalConfiguration: Array<ApprovalConfiguration>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApprovalConfiguration>>> {
            const localVarAxiosArgs = await LayoutApiAxiosParamCreator(configuration).createApprovalConfigurations(supplyChainId, approvalConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary create or update a layout
         * @param {string} supplyChainId supply chain id
         * @param {LayoutMetaBlock} layoutMetaBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateLayout(supplyChainId: string, layoutMetaBlock: LayoutMetaBlock, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LayoutMetaBlock>> {
            const localVarAxiosArgs = await LayoutApiAxiosParamCreator(configuration).createOrUpdateLayout(supplyChainId, layoutMetaBlock, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary create release configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {ReleaseConfiguration} releaseConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReleaseConfiguration(supplyChainId: string, releaseConfiguration: ReleaseConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseConfiguration>> {
            const localVarAxiosArgs = await LayoutApiAxiosParamCreator(configuration).createReleaseConfiguration(supplyChainId, releaseConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary returns a list of approval configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalConfigurations(supplyChainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApprovalConfiguration>>> {
            const localVarAxiosArgs = await LayoutApiAxiosParamCreator(configuration).getApprovalConfigurations(supplyChainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary returns a list of approvals for the login user
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalsForAccount(supplyChainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApprovalConfiguration>>> {
            const localVarAxiosArgs = await LayoutApiAxiosParamCreator(configuration).getApprovalsForAccount(supplyChainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLayout(supplyChainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LayoutMetaBlock>> {
            const localVarAxiosArgs = await LayoutApiAxiosParamCreator(configuration).getLayout(supplyChainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary returns release configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReleaseConfiguration(supplyChainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseConfiguration>> {
            const localVarAxiosArgs = await LayoutApiAxiosParamCreator(configuration).getReleaseConfiguration(supplyChainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary validates a layout on data input and model consistency
         * @param {string} supplyChainId supply chain id
         * @param {Layout} layout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateLayout(supplyChainId: string, layout: Layout, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LayoutApiAxiosParamCreator(configuration).validateLayout(supplyChainId, layout, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LayoutApi - factory interface
 * @export
 */
export const LayoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary create approval configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {Array<ApprovalConfiguration>} approvalConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApprovalConfigurations(supplyChainId: string, approvalConfiguration: Array<ApprovalConfiguration>, options?: any): AxiosPromise<Array<ApprovalConfiguration>> {
            return LayoutApiFp(configuration).createApprovalConfigurations(supplyChainId, approvalConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create or update a layout
         * @param {string} supplyChainId supply chain id
         * @param {LayoutMetaBlock} layoutMetaBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateLayout(supplyChainId: string, layoutMetaBlock: LayoutMetaBlock, options?: any): AxiosPromise<LayoutMetaBlock> {
            return LayoutApiFp(configuration).createOrUpdateLayout(supplyChainId, layoutMetaBlock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create release configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {ReleaseConfiguration} releaseConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReleaseConfiguration(supplyChainId: string, releaseConfiguration: ReleaseConfiguration, options?: any): AxiosPromise<ReleaseConfiguration> {
            return LayoutApiFp(configuration).createReleaseConfiguration(supplyChainId, releaseConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns a list of approval configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalConfigurations(supplyChainId: string, options?: any): AxiosPromise<Array<ApprovalConfiguration>> {
            return LayoutApiFp(configuration).getApprovalConfigurations(supplyChainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns a list of approvals for the login user
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalsForAccount(supplyChainId: string, options?: any): AxiosPromise<Array<ApprovalConfiguration>> {
            return LayoutApiFp(configuration).getApprovalsForAccount(supplyChainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayout(supplyChainId: string, options?: any): AxiosPromise<LayoutMetaBlock> {
            return LayoutApiFp(configuration).getLayout(supplyChainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns release configurations for a layout
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseConfiguration(supplyChainId: string, options?: any): AxiosPromise<ReleaseConfiguration> {
            return LayoutApiFp(configuration).getReleaseConfiguration(supplyChainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary validates a layout on data input and model consistency
         * @param {string} supplyChainId supply chain id
         * @param {Layout} layout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLayout(supplyChainId: string, layout: Layout, options?: any): AxiosPromise<void> {
            return LayoutApiFp(configuration).validateLayout(supplyChainId, layout, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LayoutApi - object-oriented interface
 * @export
 * @class LayoutApi
 * @extends {BaseAPI}
 */
export class LayoutApi extends BaseAPI {
    /**
     * 
     * @summary create approval configurations for a layout
     * @param {string} supplyChainId supply chain id
     * @param {Array<ApprovalConfiguration>} approvalConfiguration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public createApprovalConfigurations(supplyChainId: string, approvalConfiguration: Array<ApprovalConfiguration>, options?: any) {
        return LayoutApiFp(this.configuration).createApprovalConfigurations(supplyChainId, approvalConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create or update a layout
     * @param {string} supplyChainId supply chain id
     * @param {LayoutMetaBlock} layoutMetaBlock 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public createOrUpdateLayout(supplyChainId: string, layoutMetaBlock: LayoutMetaBlock, options?: any) {
        return LayoutApiFp(this.configuration).createOrUpdateLayout(supplyChainId, layoutMetaBlock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create release configurations for a layout
     * @param {string} supplyChainId supply chain id
     * @param {ReleaseConfiguration} releaseConfiguration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public createReleaseConfiguration(supplyChainId: string, releaseConfiguration: ReleaseConfiguration, options?: any) {
        return LayoutApiFp(this.configuration).createReleaseConfiguration(supplyChainId, releaseConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns a list of approval configurations for a layout
     * @param {string} supplyChainId supply chain id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getApprovalConfigurations(supplyChainId: string, options?: any) {
        return LayoutApiFp(this.configuration).getApprovalConfigurations(supplyChainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns a list of approvals for the login user
     * @param {string} supplyChainId supply chain id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getApprovalsForAccount(supplyChainId: string, options?: any) {
        return LayoutApiFp(this.configuration).getApprovalsForAccount(supplyChainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get layout
     * @param {string} supplyChainId supply chain id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getLayout(supplyChainId: string, options?: any) {
        return LayoutApiFp(this.configuration).getLayout(supplyChainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns release configurations for a layout
     * @param {string} supplyChainId supply chain id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getReleaseConfiguration(supplyChainId: string, options?: any) {
        return LayoutApiFp(this.configuration).getReleaseConfiguration(supplyChainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary validates a layout on data input and model consistency
     * @param {string} supplyChainId supply chain id
     * @param {Layout} layout 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public validateLayout(supplyChainId: string, layout: Layout, options?: any) {
        return LayoutApiFp(this.configuration).validateLayout(supplyChainId, layout, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LinkApi - axios parameter creator
 * @export
 */
export const LinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a link
         * @param {string} supplyChainId supply chain id
         * @param {LinkMetaBlock} [linkMetaBlock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink: async (supplyChainId: string, linkMetaBlock?: LinkMetaBlock, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling createLink.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/link`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof linkMetaBlock !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(linkMetaBlock !== undefined ? linkMetaBlock : {})
                : (linkMetaBlock || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary find link
         * @param {string} supplyChainId supply chain id
         * @param {string} [hash] hash of product or material
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLink: async (supplyChainId: string, hash?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling findLink.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/link`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LinkApi - functional programming interface
 * @export
 */
export const LinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a link
         * @param {string} supplyChainId supply chain id
         * @param {LinkMetaBlock} [linkMetaBlock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLink(supplyChainId: string, linkMetaBlock?: LinkMetaBlock, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LinkApiAxiosParamCreator(configuration).createLink(supplyChainId, linkMetaBlock, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary find link
         * @param {string} supplyChainId supply chain id
         * @param {string} [hash] hash of product or material
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLink(supplyChainId: string, hash?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LinkMetaBlock>>> {
            const localVarAxiosArgs = await LinkApiAxiosParamCreator(configuration).findLink(supplyChainId, hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LinkApi - factory interface
 * @export
 */
export const LinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a link
         * @param {string} supplyChainId supply chain id
         * @param {LinkMetaBlock} [linkMetaBlock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink(supplyChainId: string, linkMetaBlock?: LinkMetaBlock, options?: any): AxiosPromise<void> {
            return LinkApiFp(configuration).createLink(supplyChainId, linkMetaBlock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary find link
         * @param {string} supplyChainId supply chain id
         * @param {string} [hash] hash of product or material
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLink(supplyChainId: string, hash?: string, options?: any): AxiosPromise<Array<LinkMetaBlock>> {
            return LinkApiFp(configuration).findLink(supplyChainId, hash, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LinkApi - object-oriented interface
 * @export
 * @class LinkApi
 * @extends {BaseAPI}
 */
export class LinkApi extends BaseAPI {
    /**
     * 
     * @summary Create a link
     * @param {string} supplyChainId supply chain id
     * @param {LinkMetaBlock} [linkMetaBlock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    public createLink(supplyChainId: string, linkMetaBlock?: LinkMetaBlock, options?: any) {
        return LinkApiFp(this.configuration).createLink(supplyChainId, linkMetaBlock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary find link
     * @param {string} supplyChainId supply chain id
     * @param {string} [hash] hash of product or material
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    public findLink(supplyChainId: string, hash?: string, options?: any) {
        return LinkApiFp(this.configuration).findLink(supplyChainId, hash, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OauthProviderApi - axios parameter creator
 * @export
 */
export const OauthProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get a list of configured oauth providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthProviders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauthprovider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthProviderApi - functional programming interface
 * @export
 */
export const OauthProviderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get a list of configured oauth providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuthProviders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OAuthProvider>>> {
            const localVarAxiosArgs = await OauthProviderApiAxiosParamCreator(configuration).getOAuthProviders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OauthProviderApi - factory interface
 * @export
 */
export const OauthProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get a list of configured oauth providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthProviders(options?: any): AxiosPromise<Array<OAuthProvider>> {
            return OauthProviderApiFp(configuration).getOAuthProviders(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OauthProviderApi - object-oriented interface
 * @export
 * @class OauthProviderApi
 * @extends {BaseAPI}
 */
export class OauthProviderApi extends BaseAPI {
    /**
     * 
     * @summary get a list of configured oauth providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthProviderApi
     */
    public getOAuthProviders(options?: any) {
        return OauthProviderApiFp(this.configuration).getOAuthProviders(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary gets all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary gets all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/global/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary gets all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
            const localVarAxiosArgs = await PermissionsApiAxiosParamCreator(configuration).getPermissions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary gets all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await PermissionsApiAxiosParamCreator(configuration).getRoles(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary gets all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions(options?: any): AxiosPromise<Array<Permission>> {
            return PermissionsApiFp(configuration).getPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary gets all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any): AxiosPromise<Array<Role>> {
            return PermissionsApiFp(configuration).getRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * 
     * @summary gets all permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getPermissions(options?: any) {
        return PermissionsApiFp(this.configuration).getPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary gets all roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getRoles(options?: any) {
        return PermissionsApiFp(this.configuration).getRoles(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonalAccountApi - axios parameter creator
 * @export
 */
export const PersonalAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary creates a new active public and private key pair
         * @param {KeyPair} keyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (keyPair: KeyPair, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyPair' is not null or undefined
            if (keyPair === null || keyPair === undefined) {
                throw new RequiredError('keyPair','Required parameter keyPair was null or undefined when calling createKey.');
            }
            const localVarPath = `/personalaccount/me/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof keyPair !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(keyPair !== undefined ? keyPair : {})
                : (keyPair || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns all the local permissions of the personalaccount
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLocalPermissions: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAllLocalPermissions.');
            }
            const localVarPath = `/personalaccount/{accountId}/localpermission`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary gets the currently active a key pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyPair: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/personalaccount/me/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the local permissions of the personalaccount and label
         * @param {string} accountId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalPermissionsForLabel: async (accountId: string, labelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getLocalPermissionsForLabel.');
            }
            // verify required parameter 'labelId' is not null or undefined
            if (labelId === null || labelId === undefined) {
                throw new RequiredError('labelId','Required parameter labelId was null or undefined when calling getLocalPermissionsForLabel.');
            }
            const localVarPath = `/personalaccount/{accountId}/localpermission/{labelId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"labelId"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get personal account by id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalAccountById: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getPersonalAccountById.');
            }
            const localVarPath = `/personalaccount/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get active key by personal account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalAccountKeyById: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getPersonalAccountKeyById.');
            }
            const localVarPath = `/personalaccount/{accountId}/key`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the personal account profile of the authenticated personal account based on the bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalAccountOfAuthenticatedUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/personalaccount/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/personalaccount/me/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/personalaccount/me/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary search
         * @param {string} [localPermissionsLabelId] 
         * @param {string} [name] 
         * @param {Array<string>} [activeKeyIds] 
         * @param {Array<string>} [inactiveKeyIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonalAccounts: async (localPermissionsLabelId?: string, name?: string, activeKeyIds?: Array<string>, inactiveKeyIds?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/personalaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (localPermissionsLabelId !== undefined) {
                localVarQueryParameter['localPermissionsLabelId'] = localPermissionsLabelId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (activeKeyIds) {
                localVarQueryParameter['activeKeyIds'] = activeKeyIds.join(COLLECTION_FORMATS.csv);
            }

            if (inactiveKeyIds) {
                localVarQueryParameter['inactiveKeyIds'] = inactiveKeyIds.join(COLLECTION_FORMATS.csv);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary search
         * @param {Role} [role] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonalAccountsWithRoles: async (role?: Role, name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/personalaccountwithroles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updates permissions of the personalaccount and label when the permissions list is empty the permissions are removed
         * @param {string} accountId 
         * @param {string} labelId 
         * @param {Array<Permission>} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocalPermissionsForLabel: async (accountId: string, labelId: string, permission: Array<Permission>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling updateLocalPermissionsForLabel.');
            }
            // verify required parameter 'labelId' is not null or undefined
            if (labelId === null || labelId === undefined) {
                throw new RequiredError('labelId','Required parameter labelId was null or undefined when calling updateLocalPermissionsForLabel.');
            }
            // verify required parameter 'permission' is not null or undefined
            if (permission === null || permission === undefined) {
                throw new RequiredError('permission','Required parameter permission was null or undefined when calling updateLocalPermissionsForLabel.');
            }
            const localVarPath = `/personalaccount/{accountId}/localpermission/{labelId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"labelId"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof permission !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(permission !== undefined ? permission : {})
                : (permission || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update personal account roles by id
         * @param {string} accountId 
         * @param {Array<Role>} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonalAccountRolesById: async (accountId: string, role: Array<Role>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling updatePersonalAccountRolesById.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling updatePersonalAccountRolesById.');
            }
            const localVarPath = `/personalaccount/{accountId}/role`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof role !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(role !== undefined ? role : {})
                : (role || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccountApi - functional programming interface
 * @export
 */
export const PersonalAccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary creates a new active public and private key pair
         * @param {KeyPair} keyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(keyPair: KeyPair, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).createKey(keyPair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary returns all the local permissions of the personalaccount
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllLocalPermissions(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocalPermissions>>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).getAllLocalPermissions(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary gets the currently active a key pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeyPair(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyPair>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).getKeyPair(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary returns the local permissions of the personalaccount and label
         * @param {string} accountId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalPermissionsForLabel(accountId: string, labelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalPermissions>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).getLocalPermissionsForLabel(accountId, labelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get personal account by id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonalAccountById(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccount>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).getPersonalAccountById(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get active key by personal account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonalAccountKeyById(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).getPersonalAccountKeyById(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary returns the personal account profile of the authenticated personal account based on the bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonalAccountOfAuthenticatedUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).getPersonalAccountOfAuthenticatedUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).logout(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).refreshToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary search
         * @param {string} [localPermissionsLabelId] 
         * @param {string} [name] 
         * @param {Array<string>} [activeKeyIds] 
         * @param {Array<string>} [inactiveKeyIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPersonalAccounts(localPermissionsLabelId?: string, name?: string, activeKeyIds?: Array<string>, inactiveKeyIds?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonalAccount>>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).searchPersonalAccounts(localPermissionsLabelId, name, activeKeyIds, inactiveKeyIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary search
         * @param {Role} [role] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPersonalAccountsWithRoles(role?: Role, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonalAccount>>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).searchPersonalAccountsWithRoles(role, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary updates permissions of the personalaccount and label when the permissions list is empty the permissions are removed
         * @param {string} accountId 
         * @param {string} labelId 
         * @param {Array<Permission>} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLocalPermissionsForLabel(accountId: string, labelId: string, permission: Array<Permission>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalPermissions>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).updateLocalPermissionsForLabel(accountId, labelId, permission, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary update personal account roles by id
         * @param {string} accountId 
         * @param {Array<Role>} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersonalAccountRolesById(accountId: string, role: Array<Role>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccount>> {
            const localVarAxiosArgs = await PersonalAccountApiAxiosParamCreator(configuration).updatePersonalAccountRolesById(accountId, role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonalAccountApi - factory interface
 * @export
 */
export const PersonalAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary creates a new active public and private key pair
         * @param {KeyPair} keyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(keyPair: KeyPair, options?: any): AxiosPromise<void> {
            return PersonalAccountApiFp(configuration).createKey(keyPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns all the local permissions of the personalaccount
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLocalPermissions(accountId: string, options?: any): AxiosPromise<Array<LocalPermissions>> {
            return PersonalAccountApiFp(configuration).getAllLocalPermissions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary gets the currently active a key pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyPair(options?: any): AxiosPromise<KeyPair> {
            return PersonalAccountApiFp(configuration).getKeyPair(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the local permissions of the personalaccount and label
         * @param {string} accountId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalPermissionsForLabel(accountId: string, labelId: string, options?: any): AxiosPromise<LocalPermissions> {
            return PersonalAccountApiFp(configuration).getLocalPermissionsForLabel(accountId, labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get personal account by id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalAccountById(accountId: string, options?: any): AxiosPromise<PersonalAccount> {
            return PersonalAccountApiFp(configuration).getPersonalAccountById(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get active key by personal account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalAccountKeyById(accountId: string, options?: any): AxiosPromise<PublicKey> {
            return PersonalAccountApiFp(configuration).getPersonalAccountKeyById(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the personal account profile of the authenticated personal account based on the bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalAccountOfAuthenticatedUser(options?: any): AxiosPromise<Profile> {
            return PersonalAccountApiFp(configuration).getPersonalAccountOfAuthenticatedUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return PersonalAccountApiFp(configuration).logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any): AxiosPromise<Token> {
            return PersonalAccountApiFp(configuration).refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary search
         * @param {string} [localPermissionsLabelId] 
         * @param {string} [name] 
         * @param {Array<string>} [activeKeyIds] 
         * @param {Array<string>} [inactiveKeyIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonalAccounts(localPermissionsLabelId?: string, name?: string, activeKeyIds?: Array<string>, inactiveKeyIds?: Array<string>, options?: any): AxiosPromise<Array<PersonalAccount>> {
            return PersonalAccountApiFp(configuration).searchPersonalAccounts(localPermissionsLabelId, name, activeKeyIds, inactiveKeyIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary search
         * @param {Role} [role] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonalAccountsWithRoles(role?: Role, name?: string, options?: any): AxiosPromise<Array<PersonalAccount>> {
            return PersonalAccountApiFp(configuration).searchPersonalAccountsWithRoles(role, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updates permissions of the personalaccount and label when the permissions list is empty the permissions are removed
         * @param {string} accountId 
         * @param {string} labelId 
         * @param {Array<Permission>} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocalPermissionsForLabel(accountId: string, labelId: string, permission: Array<Permission>, options?: any): AxiosPromise<LocalPermissions> {
            return PersonalAccountApiFp(configuration).updateLocalPermissionsForLabel(accountId, labelId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update personal account roles by id
         * @param {string} accountId 
         * @param {Array<Role>} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonalAccountRolesById(accountId: string, role: Array<Role>, options?: any): AxiosPromise<PersonalAccount> {
            return PersonalAccountApiFp(configuration).updatePersonalAccountRolesById(accountId, role, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonalAccountApi - object-oriented interface
 * @export
 * @class PersonalAccountApi
 * @extends {BaseAPI}
 */
export class PersonalAccountApi extends BaseAPI {
    /**
     * 
     * @summary creates a new active public and private key pair
     * @param {KeyPair} keyPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public createKey(keyPair: KeyPair, options?: any) {
        return PersonalAccountApiFp(this.configuration).createKey(keyPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns all the local permissions of the personalaccount
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public getAllLocalPermissions(accountId: string, options?: any) {
        return PersonalAccountApiFp(this.configuration).getAllLocalPermissions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary gets the currently active a key pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public getKeyPair(options?: any) {
        return PersonalAccountApiFp(this.configuration).getKeyPair(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the local permissions of the personalaccount and label
     * @param {string} accountId 
     * @param {string} labelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public getLocalPermissionsForLabel(accountId: string, labelId: string, options?: any) {
        return PersonalAccountApiFp(this.configuration).getLocalPermissionsForLabel(accountId, labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get personal account by id
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public getPersonalAccountById(accountId: string, options?: any) {
        return PersonalAccountApiFp(this.configuration).getPersonalAccountById(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get active key by personal account id
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public getPersonalAccountKeyById(accountId: string, options?: any) {
        return PersonalAccountApiFp(this.configuration).getPersonalAccountKeyById(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the personal account profile of the authenticated personal account based on the bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public getPersonalAccountOfAuthenticatedUser(options?: any) {
        return PersonalAccountApiFp(this.configuration).getPersonalAccountOfAuthenticatedUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public logout(options?: any) {
        return PersonalAccountApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public refreshToken(options?: any) {
        return PersonalAccountApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary search
     * @param {string} [localPermissionsLabelId] 
     * @param {string} [name] 
     * @param {Array<string>} [activeKeyIds] 
     * @param {Array<string>} [inactiveKeyIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public searchPersonalAccounts(localPermissionsLabelId?: string, name?: string, activeKeyIds?: Array<string>, inactiveKeyIds?: Array<string>, options?: any) {
        return PersonalAccountApiFp(this.configuration).searchPersonalAccounts(localPermissionsLabelId, name, activeKeyIds, inactiveKeyIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary search
     * @param {Role} [role] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public searchPersonalAccountsWithRoles(role?: Role, name?: string, options?: any) {
        return PersonalAccountApiFp(this.configuration).searchPersonalAccountsWithRoles(role, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updates permissions of the personalaccount and label when the permissions list is empty the permissions are removed
     * @param {string} accountId 
     * @param {string} labelId 
     * @param {Array<Permission>} permission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public updateLocalPermissionsForLabel(accountId: string, labelId: string, permission: Array<Permission>, options?: any) {
        return PersonalAccountApiFp(this.configuration).updateLocalPermissionsForLabel(accountId, labelId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update personal account roles by id
     * @param {string} accountId 
     * @param {Array<Role>} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccountApi
     */
    public updatePersonalAccountRolesById(accountId: string, role: Array<Role>, options?: any) {
        return PersonalAccountApiFp(this.configuration).updatePersonalAccountRolesById(accountId, role, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReleaseApi - axios parameter creator
 * @export
 */
export const ReleaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary releases a list of artifact sets these sets will be verified
         * @param {string} supplyChainId supply chain id
         * @param {ReleaseArtifacts} releaseArtifacts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelease: async (supplyChainId: string, releaseArtifacts: ReleaseArtifacts, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling createRelease.');
            }
            // verify required parameter 'releaseArtifacts' is not null or undefined
            if (releaseArtifacts === null || releaseArtifacts === undefined) {
                throw new RequiredError('releaseArtifacts','Required parameter releaseArtifacts was null or undefined when calling createRelease.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/release`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof releaseArtifacts !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(releaseArtifacts !== undefined ? releaseArtifacts : {})
                : (releaseArtifacts || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReleaseApi - functional programming interface
 * @export
 */
export const ReleaseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary releases a list of artifact sets these sets will be verified
         * @param {string} supplyChainId supply chain id
         * @param {ReleaseArtifacts} releaseArtifacts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelease(supplyChainId: string, releaseArtifacts: ReleaseArtifacts, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseResult>> {
            const localVarAxiosArgs = await ReleaseApiAxiosParamCreator(configuration).createRelease(supplyChainId, releaseArtifacts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReleaseApi - factory interface
 * @export
 */
export const ReleaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary releases a list of artifact sets these sets will be verified
         * @param {string} supplyChainId supply chain id
         * @param {ReleaseArtifacts} releaseArtifacts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelease(supplyChainId: string, releaseArtifacts: ReleaseArtifacts, options?: any): AxiosPromise<ReleaseResult> {
            return ReleaseApiFp(configuration).createRelease(supplyChainId, releaseArtifacts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReleaseApi - object-oriented interface
 * @export
 * @class ReleaseApi
 * @extends {BaseAPI}
 */
export class ReleaseApi extends BaseAPI {
    /**
     * 
     * @summary releases a list of artifact sets these sets will be verified
     * @param {string} supplyChainId supply chain id
     * @param {ReleaseArtifacts} releaseArtifacts 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    public createRelease(supplyChainId: string, releaseArtifacts: ReleaseArtifacts, options?: any) {
        return ReleaseApiFp(this.configuration).createRelease(supplyChainId, releaseArtifacts, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchAccountApi - axios parameter creator
 * @export
 */
export const SearchAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary searches for service accounts and personal accounts
         * @param {string} supplyChainId supply chain id
         * @param {string} name 
         * @param {AccountType} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: async (supplyChainId: string, name: string, accountType?: AccountType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling searchAccounts.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling searchAccounts.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/account`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary searches on keys of service accounts and personal accounts
         * @param {string} supplyChainId supply chain id
         * @param {Array<string>} [keyIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchKeysFromAccount: async (supplyChainId: string, keyIds?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling searchKeysFromAccount.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/account/key`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (keyIds) {
                localVarQueryParameter['keyIds'] = keyIds.join(COLLECTION_FORMATS.csv);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchAccountApi - functional programming interface
 * @export
 */
export const SearchAccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary searches for service accounts and personal accounts
         * @param {string} supplyChainId supply chain id
         * @param {string} name 
         * @param {AccountType} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccounts(supplyChainId: string, name: string, accountType?: AccountType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountInfo>>> {
            const localVarAxiosArgs = await SearchAccountApiAxiosParamCreator(configuration).searchAccounts(supplyChainId, name, accountType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary searches on keys of service accounts and personal accounts
         * @param {string} supplyChainId supply chain id
         * @param {Array<string>} [keyIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchKeysFromAccount(supplyChainId: string, keyIds?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountKeyInfo>>> {
            const localVarAxiosArgs = await SearchAccountApiAxiosParamCreator(configuration).searchKeysFromAccount(supplyChainId, keyIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchAccountApi - factory interface
 * @export
 */
export const SearchAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary searches for service accounts and personal accounts
         * @param {string} supplyChainId supply chain id
         * @param {string} name 
         * @param {AccountType} [accountType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(supplyChainId: string, name: string, accountType?: AccountType, options?: any): AxiosPromise<Array<AccountInfo>> {
            return SearchAccountApiFp(configuration).searchAccounts(supplyChainId, name, accountType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary searches on keys of service accounts and personal accounts
         * @param {string} supplyChainId supply chain id
         * @param {Array<string>} [keyIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchKeysFromAccount(supplyChainId: string, keyIds?: Array<string>, options?: any): AxiosPromise<Array<AccountKeyInfo>> {
            return SearchAccountApiFp(configuration).searchKeysFromAccount(supplyChainId, keyIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchAccountApi - object-oriented interface
 * @export
 * @class SearchAccountApi
 * @extends {BaseAPI}
 */
export class SearchAccountApi extends BaseAPI {
    /**
     * 
     * @summary searches for service accounts and personal accounts
     * @param {string} supplyChainId supply chain id
     * @param {string} name 
     * @param {AccountType} [accountType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAccountApi
     */
    public searchAccounts(supplyChainId: string, name: string, accountType?: AccountType, options?: any) {
        return SearchAccountApiFp(this.configuration).searchAccounts(supplyChainId, name, accountType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary searches on keys of service accounts and personal accounts
     * @param {string} supplyChainId supply chain id
     * @param {Array<string>} [keyIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAccountApi
     */
    public searchKeysFromAccount(supplyChainId: string, keyIds?: Array<string>, options?: any) {
        return SearchAccountApiFp(this.configuration).searchKeysFromAccount(supplyChainId, keyIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceAccountApi - axios parameter creator
 * @export
 */
export const ServiceAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create a new service account
         * @param {ServiceAccount} [serviceAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount: async (serviceAccount?: ServiceAccount, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/serviceaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof serviceAccount !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(serviceAccount !== undefined ? serviceAccount : {})
                : (serviceAccount || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create a new active key the old key will be made inactive
         * @param {string} serviceAccountId 
         * @param {ServiceAccountKeyPair} [serviceAccountKeyPair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccountKeyById: async (serviceAccountId: string, serviceAccountKeyPair?: ServiceAccountKeyPair, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new RequiredError('serviceAccountId','Required parameter serviceAccountId was null or undefined when calling createServiceAccountKeyById.');
            }
            const localVarPath = `/serviceaccount/{serviceAccountId}/key`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof serviceAccountKeyPair !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(serviceAccountKeyPair !== undefined ? serviceAccountKeyPair : {})
                : (serviceAccountKeyPair || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes a service account
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount: async (serviceAccountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new RequiredError('serviceAccountId','Required parameter serviceAccountId was null or undefined when calling deleteServiceAccount.');
            }
            const localVarPath = `/serviceaccount/{serviceAccountId}`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary find service account by id
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountById: async (serviceAccountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new RequiredError('serviceAccountId','Required parameter serviceAccountId was null or undefined when calling getServiceAccountById.');
            }
            const localVarPath = `/serviceaccount/{serviceAccountId}`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary return the active key pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountKey: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/serviceaccount/me/activekey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary return the active key pair
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountKeyById: async (serviceAccountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new RequiredError('serviceAccountId','Required parameter serviceAccountId was null or undefined when calling getServiceAccountKeyById.');
            }
            const localVarPath = `/serviceaccount/{serviceAccountId}/key`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update service account by id
         * @param {string} serviceAccountId 
         * @param {ServiceAccount} [serviceAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceAccountById: async (serviceAccountId: string, serviceAccount?: ServiceAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new RequiredError('serviceAccountId','Required parameter serviceAccountId was null or undefined when calling updateServiceAccountById.');
            }
            const localVarPath = `/serviceaccount/{serviceAccountId}`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof serviceAccount !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(serviceAccount !== undefined ? serviceAccount : {})
                : (serviceAccount || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceAccountApi - functional programming interface
 * @export
 */
export const ServiceAccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create a new service account
         * @param {ServiceAccount} [serviceAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAccount(serviceAccount?: ServiceAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccount>> {
            const localVarAxiosArgs = await ServiceAccountApiAxiosParamCreator(configuration).createServiceAccount(serviceAccount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary create a new active key the old key will be made inactive
         * @param {string} serviceAccountId 
         * @param {ServiceAccountKeyPair} [serviceAccountKeyPair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAccountKeyById(serviceAccountId: string, serviceAccountKeyPair?: ServiceAccountKeyPair, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccountKeyPair>> {
            const localVarAxiosArgs = await ServiceAccountApiAxiosParamCreator(configuration).createServiceAccountKeyById(serviceAccountId, serviceAccountKeyPair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary deletes a service account
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAccount(serviceAccountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServiceAccountApiAxiosParamCreator(configuration).deleteServiceAccount(serviceAccountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary find service account by id
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccountById(serviceAccountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccount>> {
            const localVarAxiosArgs = await ServiceAccountApiAxiosParamCreator(configuration).getServiceAccountById(serviceAccountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary return the active key pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccountKey(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccountKeyPair>> {
            const localVarAxiosArgs = await ServiceAccountApiAxiosParamCreator(configuration).getServiceAccountKey(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary return the active key pair
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccountKeyById(serviceAccountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccountKeyPair>> {
            const localVarAxiosArgs = await ServiceAccountApiAxiosParamCreator(configuration).getServiceAccountKeyById(serviceAccountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary update service account by id
         * @param {string} serviceAccountId 
         * @param {ServiceAccount} [serviceAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceAccountById(serviceAccountId: string, serviceAccount?: ServiceAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccount>> {
            const localVarAxiosArgs = await ServiceAccountApiAxiosParamCreator(configuration).updateServiceAccountById(serviceAccountId, serviceAccount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ServiceAccountApi - factory interface
 * @export
 */
export const ServiceAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary create a new service account
         * @param {ServiceAccount} [serviceAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount(serviceAccount?: ServiceAccount, options?: any): AxiosPromise<ServiceAccount> {
            return ServiceAccountApiFp(configuration).createServiceAccount(serviceAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create a new active key the old key will be made inactive
         * @param {string} serviceAccountId 
         * @param {ServiceAccountKeyPair} [serviceAccountKeyPair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccountKeyById(serviceAccountId: string, serviceAccountKeyPair?: ServiceAccountKeyPair, options?: any): AxiosPromise<ServiceAccountKeyPair> {
            return ServiceAccountApiFp(configuration).createServiceAccountKeyById(serviceAccountId, serviceAccountKeyPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletes a service account
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount(serviceAccountId: string, options?: any): AxiosPromise<void> {
            return ServiceAccountApiFp(configuration).deleteServiceAccount(serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary find service account by id
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountById(serviceAccountId: string, options?: any): AxiosPromise<ServiceAccount> {
            return ServiceAccountApiFp(configuration).getServiceAccountById(serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary return the active key pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountKey(options?: any): AxiosPromise<ServiceAccountKeyPair> {
            return ServiceAccountApiFp(configuration).getServiceAccountKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary return the active key pair
         * @param {string} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountKeyById(serviceAccountId: string, options?: any): AxiosPromise<ServiceAccountKeyPair> {
            return ServiceAccountApiFp(configuration).getServiceAccountKeyById(serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update service account by id
         * @param {string} serviceAccountId 
         * @param {ServiceAccount} [serviceAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceAccountById(serviceAccountId: string, serviceAccount?: ServiceAccount, options?: any): AxiosPromise<ServiceAccount> {
            return ServiceAccountApiFp(configuration).updateServiceAccountById(serviceAccountId, serviceAccount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceAccountApi - object-oriented interface
 * @export
 * @class ServiceAccountApi
 * @extends {BaseAPI}
 */
export class ServiceAccountApi extends BaseAPI {
    /**
     * 
     * @summary create a new service account
     * @param {ServiceAccount} [serviceAccount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountApi
     */
    public createServiceAccount(serviceAccount?: ServiceAccount, options?: any) {
        return ServiceAccountApiFp(this.configuration).createServiceAccount(serviceAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create a new active key the old key will be made inactive
     * @param {string} serviceAccountId 
     * @param {ServiceAccountKeyPair} [serviceAccountKeyPair] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountApi
     */
    public createServiceAccountKeyById(serviceAccountId: string, serviceAccountKeyPair?: ServiceAccountKeyPair, options?: any) {
        return ServiceAccountApiFp(this.configuration).createServiceAccountKeyById(serviceAccountId, serviceAccountKeyPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletes a service account
     * @param {string} serviceAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountApi
     */
    public deleteServiceAccount(serviceAccountId: string, options?: any) {
        return ServiceAccountApiFp(this.configuration).deleteServiceAccount(serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary find service account by id
     * @param {string} serviceAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountApi
     */
    public getServiceAccountById(serviceAccountId: string, options?: any) {
        return ServiceAccountApiFp(this.configuration).getServiceAccountById(serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary return the active key pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountApi
     */
    public getServiceAccountKey(options?: any) {
        return ServiceAccountApiFp(this.configuration).getServiceAccountKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary return the active key pair
     * @param {string} serviceAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountApi
     */
    public getServiceAccountKeyById(serviceAccountId: string, options?: any) {
        return ServiceAccountApiFp(this.configuration).getServiceAccountKeyById(serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update service account by id
     * @param {string} serviceAccountId 
     * @param {ServiceAccount} [serviceAccount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountApi
     */
    public updateServiceAccountById(serviceAccountId: string, serviceAccount?: ServiceAccount, options?: any) {
        return ServiceAccountApiFp(this.configuration).updateServiceAccountById(serviceAccountId, serviceAccount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SupplychainApi - axios parameter creator
 * @export
 */
export const SupplychainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create a supplychain
         * @param {SupplyChain} [supplyChain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplyChain: async (supplyChain?: SupplyChain, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/supplychain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof supplyChain !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(supplyChain !== undefined ? supplyChain : {})
                : (supplyChain || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete supply chain by id. The layout, approval configs and link objects are also deleted
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSupplyChainById: async (supplyChainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling deleteSupplyChainById.');
            }
            const localVarPath = `/supplychain/{supplyChainId}`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a supplychain
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplyChain: async (supplyChainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling getSupplyChain.');
            }
            const localVarPath = `/supplychain/{supplyChainId}`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get supply chain by path
         * @param {string} name 
         * @param {Array<string>} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplyChainByPath: async (name: string, path: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getSupplyChainByPath.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getSupplyChainByPath.');
            }
            const localVarPath = `/supplychain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (path) {
                localVarQueryParameter['path'] = path.join(COLLECTION_FORMATS.csv);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update supplychain by id
         * @param {string} supplyChainId supply chain id
         * @param {SupplyChain} supplyChain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplyChain: async (supplyChainId: string, supplyChain: SupplyChain, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling updateSupplyChain.');
            }
            // verify required parameter 'supplyChain' is not null or undefined
            if (supplyChain === null || supplyChain === undefined) {
                throw new RequiredError('supplyChain','Required parameter supplyChain was null or undefined when calling updateSupplyChain.');
            }
            const localVarPath = `/supplychain/{supplyChainId}`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof supplyChain !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(supplyChain !== undefined ? supplyChain : {})
                : (supplyChain || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupplychainApi - functional programming interface
 * @export
 */
export const SupplychainApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create a supplychain
         * @param {SupplyChain} [supplyChain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupplyChain(supplyChain?: SupplyChain, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplyChain>> {
            const localVarAxiosArgs = await SupplychainApiAxiosParamCreator(configuration).createSupplyChain(supplyChain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary delete supply chain by id. The layout, approval configs and link objects are also deleted
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSupplyChainById(supplyChainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SupplychainApiAxiosParamCreator(configuration).deleteSupplyChainById(supplyChainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get a supplychain
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupplyChain(supplyChainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplyChain>> {
            const localVarAxiosArgs = await SupplychainApiAxiosParamCreator(configuration).getSupplyChain(supplyChainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get supply chain by path
         * @param {string} name 
         * @param {Array<string>} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupplyChainByPath(name: string, path: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplyChain>> {
            const localVarAxiosArgs = await SupplychainApiAxiosParamCreator(configuration).getSupplyChainByPath(name, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary update supplychain by id
         * @param {string} supplyChainId supply chain id
         * @param {SupplyChain} supplyChain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupplyChain(supplyChainId: string, supplyChain: SupplyChain, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplyChain>> {
            const localVarAxiosArgs = await SupplychainApiAxiosParamCreator(configuration).updateSupplyChain(supplyChainId, supplyChain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SupplychainApi - factory interface
 * @export
 */
export const SupplychainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary create a supplychain
         * @param {SupplyChain} [supplyChain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplyChain(supplyChain?: SupplyChain, options?: any): AxiosPromise<SupplyChain> {
            return SupplychainApiFp(configuration).createSupplyChain(supplyChain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete supply chain by id. The layout, approval configs and link objects are also deleted
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSupplyChainById(supplyChainId: string, options?: any): AxiosPromise<void> {
            return SupplychainApiFp(configuration).deleteSupplyChainById(supplyChainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a supplychain
         * @param {string} supplyChainId supply chain id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplyChain(supplyChainId: string, options?: any): AxiosPromise<SupplyChain> {
            return SupplychainApiFp(configuration).getSupplyChain(supplyChainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get supply chain by path
         * @param {string} name 
         * @param {Array<string>} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplyChainByPath(name: string, path: Array<string>, options?: any): AxiosPromise<SupplyChain> {
            return SupplychainApiFp(configuration).getSupplyChainByPath(name, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update supplychain by id
         * @param {string} supplyChainId supply chain id
         * @param {SupplyChain} supplyChain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplyChain(supplyChainId: string, supplyChain: SupplyChain, options?: any): AxiosPromise<SupplyChain> {
            return SupplychainApiFp(configuration).updateSupplyChain(supplyChainId, supplyChain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupplychainApi - object-oriented interface
 * @export
 * @class SupplychainApi
 * @extends {BaseAPI}
 */
export class SupplychainApi extends BaseAPI {
    /**
     * 
     * @summary create a supplychain
     * @param {SupplyChain} [supplyChain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplychainApi
     */
    public createSupplyChain(supplyChain?: SupplyChain, options?: any) {
        return SupplychainApiFp(this.configuration).createSupplyChain(supplyChain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete supply chain by id. The layout, approval configs and link objects are also deleted
     * @param {string} supplyChainId supply chain id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplychainApi
     */
    public deleteSupplyChainById(supplyChainId: string, options?: any) {
        return SupplychainApiFp(this.configuration).deleteSupplyChainById(supplyChainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a supplychain
     * @param {string} supplyChainId supply chain id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplychainApi
     */
    public getSupplyChain(supplyChainId: string, options?: any) {
        return SupplychainApiFp(this.configuration).getSupplyChain(supplyChainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get supply chain by path
     * @param {string} name 
     * @param {Array<string>} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplychainApi
     */
    public getSupplyChainByPath(name: string, path: Array<string>, options?: any) {
        return SupplychainApiFp(this.configuration).getSupplyChainByPath(name, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update supplychain by id
     * @param {string} supplyChainId supply chain id
     * @param {SupplyChain} supplyChain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplychainApi
     */
    public updateSupplyChain(supplyChainId: string, supplyChain: SupplyChain, options?: any) {
        return SupplychainApiFp(this.configuration).updateSupplyChain(supplyChainId, supplyChain, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checks verification on a release artifact set and possibly domains
         * @param {Array<string>} artifactHashes 
         * @param {Array<string>} [paths] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerification: async (artifactHashes: Array<string>, paths?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactHashes' is not null or undefined
            if (artifactHashes === null || artifactHashes === undefined) {
                throw new RequiredError('artifactHashes','Required parameter artifactHashes was null or undefined when calling getVerification.');
            }
            const localVarPath = `/supplychain/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (artifactHashes) {
                localVarQueryParameter['artifactHashes'] = artifactHashes.join(COLLECTION_FORMATS.csv);
            }

            if (paths) {
                localVarQueryParameter['paths'] = paths;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary creates a verification run
         * @param {string} supplyChainId supply chain id
         * @param {VerifyCommand} verifyCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performVerification: async (supplyChainId: string, verifyCommand: VerifyCommand, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplyChainId' is not null or undefined
            if (supplyChainId === null || supplyChainId === undefined) {
                throw new RequiredError('supplyChainId','Required parameter supplyChainId was null or undefined when calling performVerification.');
            }
            // verify required parameter 'verifyCommand' is not null or undefined
            if (verifyCommand === null || verifyCommand === undefined) {
                throw new RequiredError('verifyCommand','Required parameter verifyCommand was null or undefined when calling performVerification.');
            }
            const localVarPath = `/supplychain/{supplyChainId}/verification`
                .replace(`{${"supplyChainId"}}`, encodeURIComponent(String(supplyChainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof verifyCommand !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(verifyCommand !== undefined ? verifyCommand : {})
                : (verifyCommand || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checks verification on a release artifact set and possibly domains
         * @param {Array<string>} artifactHashes 
         * @param {Array<string>} [paths] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerification(artifactHashes: Array<string>, paths?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResult>> {
            const localVarAxiosArgs = await VerificationApiAxiosParamCreator(configuration).getVerification(artifactHashes, paths, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary creates a verification run
         * @param {string} supplyChainId supply chain id
         * @param {VerifyCommand} verifyCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performVerification(supplyChainId: string, verifyCommand: VerifyCommand, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResult>> {
            const localVarAxiosArgs = await VerificationApiAxiosParamCreator(configuration).performVerification(supplyChainId, verifyCommand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary checks verification on a release artifact set and possibly domains
         * @param {Array<string>} artifactHashes 
         * @param {Array<string>} [paths] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerification(artifactHashes: Array<string>, paths?: Array<string>, options?: any): AxiosPromise<VerificationResult> {
            return VerificationApiFp(configuration).getVerification(artifactHashes, paths, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary creates a verification run
         * @param {string} supplyChainId supply chain id
         * @param {VerifyCommand} verifyCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performVerification(supplyChainId: string, verifyCommand: VerifyCommand, options?: any): AxiosPromise<VerificationResult> {
            return VerificationApiFp(configuration).performVerification(supplyChainId, verifyCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * 
     * @summary checks verification on a release artifact set and possibly domains
     * @param {Array<string>} artifactHashes 
     * @param {Array<string>} [paths] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getVerification(artifactHashes: Array<string>, paths?: Array<string>, options?: any) {
        return VerificationApiFp(this.configuration).getVerification(artifactHashes, paths, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary creates a verification run
     * @param {string} supplyChainId supply chain id
     * @param {VerifyCommand} verifyCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public performVerification(supplyChainId: string, verifyCommand: VerifyCommand, options?: any) {
        return VerificationApiFp(this.configuration).performVerification(supplyChainId, verifyCommand, options).then((request) => request(this.axios, this.basePath));
    }
}


